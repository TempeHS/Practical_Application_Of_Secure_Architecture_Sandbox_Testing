#!/usr/bin/env python3
"""
Command-line interface for the Penetration Testing Module

This script provides an easy-to-use CLI for running penetration tests
on applications and infrastructure. Unlike SAST (static analysis) and DAST
(dynamic analysis), penetration testing actively attempts to exploit
vulnerabilities to demonstrate their impact.

Testing Types:
- Reconnaissance: Information gathering, port scanning, service enumeration
- Vulnerability Assessment: Automated vulnerability scanning
- Web Application Testing: XSS, SQLi, authentication, session management
- Exploitation: Proof-of-concept exploitation attempts
- Comprehensive Testing: All phases combined

Usage Examples:
    # Basic penetration test
    python pentest_cli.py http://localhost:5000

    # Deep penetration test with exploitation
    python pentest_cli.py http://localhost:5000 --deep --exploit

    # Specific test types
    python pentest_cli.py http://localhost:5000 --test-types recon vuln_scan

    # Test all demo applications
    python pentest_cli.py --demo-apps --deep

    # Generate detailed report
    python pentest_cli.py http://localhost:5000 --output pentest_report.json

    # Educational mode with explanations
    python pentest_cli.py http://localhost:5000 --educational --exploit

Security Notice:
This tool is for educational purposes and authorised penetration testing only.
Only test applications you own or have explicit permission to test.
Unauthorized penetration testing is illegal.
"""

from analyser.penetration_analyser import (
    PenetrationTester, PentestReport, pentest_demo_applications, logger
)
import argparse
import json
import sys
import os
import logging
from pathlib import Path
from typing import List, Dict, Any
from datetime import datetime

# Add the src directory to the Python path
sys.path.insert(0, str(Path(__file__).parent.parent))


# Import the report generator for markdown output
try:
    from reporter.report_generator import MarkdownReportGenerator
    MARKDOWN_AVAILABLE = True
except ImportError:
    MARKDOWN_AVAILABLE = False
    logger.warning("Markdown report generation not available")

# Import the MD to PDF converter
try:
    from tools.md_to_pdf_converter import MarkdownToPdfConverter
    PDF_AVAILABLE = True
except ImportError:
    PDF_AVAILABLE = False
    logger.warning("PDF conversion not available")


class PentestCLI:
    """Command-line interface for penetration testing"""

    def __init__(self):
        self.tester = PenetrationTester()

    def run_penetration_test(self, args) -> None:
        """Execute penetration test based on command-line arguments"""

        if args.demo_apps:
            self._test_demo_applications(args)
            return

        if not args.target:
            print("Error: Target URL is required unless using --demo-apps")
            print("Example: python pentest_cli.py http://localhost:5000")
            sys.exit(1)

        # Validate target
        target = self._validate_target(args.target)

        # Determine test configuration
        test_types = self._get_test_types(args)
        deep_test = args.deep
        exploit_mode = args.exploit

        # Security warning for exploitation mode
        if exploit_mode:
            print("‚ö†Ô∏è  WARNING: Exploitation mode enabled")
            print("   Only test applications you own or have permission to test")
            print("   Unauthorized penetration testing is illegal")

            if not args.force:
                confirm = input("Continue with exploitation? (y/N): ")
                if confirm.lower() != 'y':
                    print("Penetration test cancelled")
                    sys.exit(0)

        try:
            # Display test configuration
            print(f"üéØ Target: {target}")
            print(f"üîç Test Types: {', '.join(test_types)}")
            print(f"üìä Deep Testing: {'Yes' if deep_test else 'No'}")
            print(f"üí• Exploitation: {'Yes' if exploit_mode else 'No'}")
            print(
                f"üõ†Ô∏è  Available Tools: {', '.join([tool for tool, available in self.tester.tools_available.items() if available])}")

            print(f"\nüöÄ Starting penetration test...")

            # Run penetration test
            report = self.tester.conduct_penetration_test(
                target=target,
                test_types=test_types,
                deep_test=deep_test,
                exploit_mode=exploit_mode
            )

            # Output results
            if args.output:
                output_path = self._resolve_output_path(args.output, 'pentest')
                self._save_report(report, output_path, args.format)
                print(f"üìÑ Report saved to: {output_path}")
            else:
                # Auto-save with timestamp if no output specified
                auto_output_path = self._generate_auto_output_path(
                    'pentest', args.format)
                self._save_report(report, auto_output_path, args.format)
                print(f"üìÑ Report auto-saved to: {auto_output_path}")

            # Display results
            self._display_report(report, args.educational, args.verbose)

        except Exception as e:
            print(f"‚ùå Penetration test failed: {str(e)}")
            if args.verbose:
                import traceback
                traceback.print_exc()
            sys.exit(1)

    def _test_demo_applications(self, args) -> None:
        """Test all demo applications"""
        print("üéØ Testing all demo applications...")
        print("‚ö†Ô∏è  Make sure demo applications are running before testing")

        try:
            results = pentest_demo_applications(educational=args.educational)

            if not results:
                print("‚ùå No demo applications found or accessible")
                print("   Make sure applications are running:")
                print("   - vulnerable-flask-app: http://localhost:5000")
                print("   - unsecure-pwa: http://localhost:5000")
                print("   - vulnerable-nodejs-app: http://localhost:3000")
                return

            # Display summary for each app
            for app_name, report in results.items():
                print(f"\nüì± Application: {app_name}")
                print("=" * 60)
                self._display_report_summary(report)

                if args.educational:
                    self._display_educational_insights(report)

            # Save combined report if requested
            if args.output:
                output_path = self._resolve_output_path(
                    args.output, 'pentest_demo')
                combined_report = self._combine_reports(results)
                self._save_report(combined_report, output_path, args.format)
                print(f"\nüìÑ Combined report saved to: {output_path}")
            else:
                # Auto-save with timestamp if no output specified
                auto_output_path = self._generate_auto_output_path(
                    'pentest_demo', args.format)
                combined_report = self._combine_reports(results)
                self._save_report(
                    combined_report, auto_output_path, args.format)
                print(f"\nüìÑ Combined report auto-saved to: {auto_output_path}")

        except Exception as e:
            print(f"‚ùå Demo testing failed: {str(e)}")
            sys.exit(1)

    def _validate_target(self, target: str) -> str:
        """Validate and normalize target URL"""
        if not target.startswith(('http://', 'https://')):
            # Try to determine protocol
            if ':443' in target or 'ssl' in target.lower():
                target = f"https://{target}"
            else:
                target = f"http://{target}"

        return target

    def _get_test_types(self, args) -> List[str]:
        """Determine which test types to run"""
        if args.test_types:
            valid_types = ['recon', 'vuln_scan', 'web_app', 'exploit', 'all']

            for test_type in args.test_types:
                if test_type not in valid_types:
                    print(f"‚ö†Ô∏è  Unknown test type: {test_type}")
                    print(f"Valid types: {', '.join(valid_types)}")

            return [t for t in args.test_types if t in valid_types]

        # Default test types based on other options
        if args.exploit:
            return ['all']
        elif args.deep:
            return ['recon', 'vuln_scan', 'web_app']
        else:
            return ['recon', 'vuln_scan']

    def _display_report(self, report: PentestReport,
                        educational: bool = False, verbose: bool = False) -> None:
        """Display penetration test report to console"""

        print("\n" + "="*70)
        print("üõ°Ô∏è  PENETRATION TEST REPORT")
        print("="*70)

        # Summary
        self._display_report_summary(report)

        # Methodology
        if report.methodology:
            print(f"\nüìã METHODOLOGY:")
            for i, phase in enumerate(report.methodology, 1):
                print(f"   {i}. {phase}")

        # Findings breakdown
        if report.findings:
            print(f"\nüîç DETAILED FINDINGS ({len(report.findings)} total)")
            print("-" * 50)

            # Group findings by severity
            severity_groups = {}
            for finding in report.findings:
                severity = finding.severity
                if severity not in severity_groups:
                    severity_groups[severity] = []
                severity_groups[severity].append(finding)

            # Display by severity (highest first)
            for severity in ['critical', 'high', 'medium', 'low', 'info']:
                if severity in severity_groups:
                    count = len(severity_groups[severity])
                    print(
                        f"\nüö® {severity.upper()} SEVERITY ({count} findings)")

                    # Limit display to prevent overwhelming output
                    for i, finding in enumerate(severity_groups[severity][:10]):
                        self._display_finding(finding, educational, verbose)

                        if i >= 9 and count > 10:
                            remaining = count - 10
                            print(f"    ... and {remaining} more {severity} "
                                  "severity findings")
                            break

        # Recommendations
        if report.recommendations:
            print(f"\nüí° SECURITY RECOMMENDATIONS:")
            for i, rec in enumerate(report.recommendations[:10], 1):
                print(f"   {i}. {rec}")

        if educational:
            self._display_educational_insights(report)

    def _display_report_summary(self, report: PentestReport) -> None:
        """Display summary statistics"""
        summary = report.summary

        print(f"üéØ Target: {report.target}")
        print(f"‚è∞ Test Duration: {report.test_duration:.2f} seconds")
        print(f"üìÖ Timestamp: {report.timestamp}")
        print(
            f"üîß Tools Used: {', '.join(report.tools_used) if report.tools_used else 'None'}")

        print(f"\nüìä TEST STATISTICS:")
        print(f"   Total Tests: {report.total_tests}")
        print(f"   Services Discovered: {report.services_discovered}")
        print(f"   Endpoints Tested: {report.endpoints_tested}")
        print(f"   Successful Exploits: {report.successful_exploits}")

        print(f"\nüìä FINDINGS SUMMARY:")
        severity_dist = summary.get('severity_distribution', {})
        print(f"   Total: {summary.get('total_findings', 0)}")
        print(f"   Critical: {severity_dist.get('critical', 0)}")
        print(f"   High: {severity_dist.get('high', 0)}")
        print(f"   Medium: {severity_dist.get('medium', 0)}")
        print(f"   Low: {severity_dist.get('low', 0)}")
        print(f"   Info: {severity_dist.get('info', 0)}")

        print(f"\nüéØ OVERALL RISK ASSESSMENT:")
        risk_level = summary.get('risk_level', 'UNKNOWN')
        risk_score = summary.get('overall_risk_score', 0)
        print(f"   Risk Level: {risk_level}")
        print(f"   Risk Score: {risk_score:.1f}/100")

    def _display_finding(self, finding, educational: bool = False,
                         verbose: bool = False) -> None:
        """Display individual finding"""
        print(f"\n  [{finding.tool.upper()}] {finding.title}")
        print(f"    üéØ Target: {finding.target}")

        if finding.port:
            print(f"    üîå Port: {finding.port}")

        if finding.service:
            print(f"    üõ†Ô∏è  Service: {finding.service}")

        if verbose:
            print(f"    üìù Description: {finding.description}")

            if finding.cwe_id:
                print(f"    üåê CWE: {finding.cwe_id}")

            if finding.cvss_score:
                print(f"    üìä CVSS Score: {finding.cvss_score}")

            if finding.payload:
                print(f"    üíâ Payload: {finding.payload}")

        if finding.evidence:
            print(f"    üîç Evidence: {finding.evidence}")

        if finding.exploitation_proof:
            print(f"    üí• Exploitation: {finding.exploitation_proof}")

        if educational:
            if finding.attack_vector:
                print(f"    üéì Attack Vector: {finding.attack_vector}")

            if finding.impact:
                print(f"    üí• Impact: {finding.impact}")

            if finding.remediation:
                print(f"    üîß Remediation: {finding.remediation}")

    def _display_educational_insights(self, report: PentestReport) -> None:
        """Display educational insights and learning points"""
        print(f"\nüéì EDUCATIONAL INSIGHTS")
        print("-" * 50)

        # Analyse attack vectors
        attack_vectors = {}
        for finding in report.findings:
            vector = finding.attack_vector or 'Other'
            attack_vectors[vector] = attack_vectors.get(vector, 0) + 1

        if attack_vectors:
            print(f"üìö Attack Vectors Identified:")
            for vector, count in attack_vectors.items():
                print(
                    f"   ‚Ä¢ {vector}: {count} finding{'s' if count != 1 else ''}")

        # Educational recommendations based on findings
        print(f"\nüí° LEARNING RECOMMENDATIONS:")

        if any(f.cwe_id == 'CWE-89' for f in report.findings):
            print("   ‚Ä¢ Study SQL injection attack techniques and prevention")
            print("   ‚Ä¢ Practice parameterized query implementation")

        if any(f.cwe_id == 'CWE-79' for f in report.findings):
            print("   ‚Ä¢ Learn about XSS attack vectors and mitigation")
            print("   ‚Ä¢ Practice input validation and output encoding")

        if any(f.tool == 'port_scanner' for f in report.findings):
            print("   ‚Ä¢ Study network security and port hardening")
            print("   ‚Ä¢ Learn about service enumeration techniques")

        if any(f.exploitation_proof for f in report.findings):
            print("   ‚Ä¢ Understand the difference between detection and exploitation")
            print("   ‚Ä¢ Study responsible disclosure practices")

        if report.successful_exploits > 0:
            print(
                f"   ‚Ä¢ {report.successful_exploits} vulnerabilities were successfully exploited")
            print("   ‚Ä¢ Practice incident response and forensics")

        print("   ‚Ä¢ Review OWASP Top 10 and implement secure coding practices")
        print("   ‚Ä¢ Study penetration testing methodologies (OWASP WSTG, NIST)")

    def _resolve_output_path(self, output_path: str, scan_type: str) -> str:
        """Resolve output path, ensuring it goes to reports directory"""
        import os

        # If absolute path, use as-is
        if os.path.isabs(output_path):
            return output_path

        # If relative path, check if it's just a filename
        if os.path.dirname(output_path) == '':
            # Just a filename, put it in reports directory
            reports_dir = os.path.join(os.getcwd(), 'reports')
            os.makedirs(reports_dir, exist_ok=True)
            return os.path.join(reports_dir, output_path)

        # Relative path with directory, use as-is
        return output_path

    def _generate_auto_output_path(self, scan_type: str, format_type: str) -> str:
        """Generate automatic output path with timestamp"""
        import os

        # Create reports directory if it doesn't exist
        reports_dir = os.path.join(os.getcwd(), 'reports')
        os.makedirs(reports_dir, exist_ok=True)

        # Generate timestamped filename
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        extension = 'json' if format_type == 'json' else 'txt'
        filename = f"{scan_type}_report_{timestamp}.{extension}"

        return os.path.join(reports_dir, filename)

    def _save_report(self, report: PentestReport, output_path: str,
                     format_type: str) -> None:
        """Save report to file with support for multiple formats"""

        # Convert to dict (needed for all formats)
        report_dict = report.to_dict()

        if format_type == 'json':
            # JSON only
            with open(output_path, 'w') as f:
                json.dump(report_dict, f, indent=2)

        elif format_type == 'md':
            # JSON + Markdown
            # Save JSON file
            json_path = output_path.replace('.md', '.json')
            with open(json_path, 'w') as f:
                json.dump(report_dict, f, indent=2)
            print(f"üìÑ JSON report saved to: {json_path}")

            # Generate markdown report
            if MARKDOWN_AVAILABLE:
                try:
                    generator = MarkdownReportGenerator()
                    generator.generate_markdown_report(
                        json_data=report_dict,
                        analyser_type='pentest',
                        output_file=os.path.basename(output_path)
                    )
                    print(f"üìÑ Markdown report saved to: {output_path}")
                except Exception as e:
                    logger.error(f"Failed to generate markdown report: {e}")
                    print(f"‚ùå Markdown generation failed: {e}")
            else:
                print("‚ùå Markdown generation not available")

        elif format_type == 'pdf':
            # JSON + Markdown + PDF
            # Save JSON file
            json_path = output_path.replace('.pdf', '.json')
            with open(json_path, 'w') as f:
                json.dump(report_dict, f, indent=2)
            print(f"üìÑ JSON report saved to: {json_path}")

            # Generate markdown report
            if MARKDOWN_AVAILABLE:
                try:
                    markdown_path = output_path.replace('.pdf', '.md')
                    generator = MarkdownReportGenerator()
                    generator.generate_markdown_report(
                        json_data=report_dict,
                        analyser_type='pentest',
                        output_file=os.path.basename(markdown_path)
                    )
                    print(f"üìÑ Markdown report saved to: {markdown_path}")

                    # Convert to PDF
                    if PDF_AVAILABLE:
                        try:
                            converter = MarkdownToPdfConverter(
                                page_break_mode="continuous"
                            )
                            converter.convert_file_to_pdf(
                                input_file=Path(markdown_path),
                                output_file=Path(output_path)
                            )
                            print(f"üìÑ PDF report saved to: {output_path}")
                        except Exception as e:
                            logger.error(f"Failed to convert to PDF: {e}")
                            print(f"‚ùå PDF conversion failed: {e}")
                    else:
                        print("‚ùå PDF conversion not available")

                except Exception as e:
                    logger.error(f"Failed to generate markdown report: {e}")
                    print(f"‚ùå Markdown generation failed: {e}")
            else:
                print("‚ùå Markdown generation not available")

        elif format_type == 'txt':
            # Text format (legacy)
            with open(output_path, 'w') as f:
                f.write("PENETRATION TEST REPORT\n")
                f.write("=" * 70 + "\n\n")

                f.write(f"Target: {report.target}\n")
                f.write(f"Test Duration: {report.test_duration:.2f} seconds\n")
                f.write(f"Timestamp: {report.timestamp}\n")
                f.write(f"Tools Used: {', '.join(report.tools_used)}\n\n")

                f.write("SUMMARY:\n")
                f.write(f"  Total Tests: {report.total_tests}\n")
                f.write(
                    f"  Services Discovered: {report.services_discovered}\n")
                f.write(
                    f"  Successful Exploits: {report.successful_exploits}\n")
                f.write(
                    f"  Risk Level: {report.summary.get('risk_level', 'UNKNOWN')}\n\n")

                severity_dist = report.summary.get('severity_distribution', {})
                f.write("FINDINGS BY SEVERITY:\n")
                for severity in ['critical', 'high', 'medium', 'low', 'info']:
                    count = severity_dist.get(severity, 0)
                    f.write(f"  {severity.title()}: {count}\n")

                f.write(
                    f"\nDETAILED FINDINGS ({len(report.findings)} total):\n")
                f.write("-" * 50 + "\n")

                for i, finding in enumerate(report.findings, 1):
                    f.write(
                        f"\n{i}. [{finding.severity.upper()}] {finding.title}\n")
                    f.write(f"   Tool: {finding.tool}\n")
                    f.write(f"   Target: {finding.target}\n")
                    if finding.port:
                        f.write(f"   Port: {finding.port}\n")
                    f.write(f"   Description: {finding.description}\n")

                    if finding.evidence:
                        f.write(f"   Evidence: {finding.evidence}\n")

                    if finding.exploitation_proof:
                        f.write(
                            f"   Exploitation: {finding.exploitation_proof}\n")

                if report.recommendations:
                    f.write(f"\nRECOMMENDATIONS:\n")
                    for i, rec in enumerate(report.recommendations, 1):
                        f.write(f"{i}. {rec}\n")

    def _combine_reports(self, reports_dict: Dict[str, PentestReport]) -> PentestReport:
        """Combine multiple reports into one"""
        combined_findings = []
        combined_tools = set()
        total_tests = 0
        total_exploits = 0
        total_services = 0
        total_endpoints = 0

        for app_name, report in reports_dict.items():
            # Prefix findings with app name for clarity
            for finding in report.findings:
                finding.target = f"{app_name}:{finding.target}"

            combined_findings.extend(report.findings)
            combined_tools.update(report.tools_used)
            total_tests += report.total_tests
            total_exploits += report.successful_exploits
            total_services += report.services_discovered
            total_endpoints += report.endpoints_tested

        # Generate combined summary
        severity_counts = {'critical': 0, 'high': 0,
                           'medium': 0, 'low': 0, 'info': 0}
        for finding in combined_findings:
            severity_counts[finding.severity] += 1

        summary = {
            'total_findings': len(combined_findings),
            'severity_distribution': severity_counts,
            'overall_risk_score': self._calculate_risk_score(severity_counts),
            'risk_level': self._get_risk_level(
                self._calculate_risk_score(severity_counts))
        }

        # Combine recommendations
        combined_recommendations = []
        for report in reports_dict.values():
            combined_recommendations.extend(report.recommendations)
        # Remove duplicates while preserving order
        unique_recommendations = list(dict.fromkeys(combined_recommendations))

        return PentestReport(
            target="Combined Demo Applications",
            test_duration=sum(r.test_duration for r in reports_dict.values()),
            timestamp=list(reports_dict.values())[0].timestamp,
            findings=combined_findings,
            tools_used=list(combined_tools),
            total_tests=total_tests,
            successful_exploits=total_exploits,
            services_discovered=total_services,
            endpoints_tested=total_endpoints,
            summary=summary,
            methodology=["Combined Analysis"],
            # Limit recommendations
            recommendations=unique_recommendations[:10]
        )

    def _calculate_risk_score(self, severity_counts: Dict[str, int]) -> float:
        """Calculate overall risk score based on findings"""
        weights = {'critical': 10, 'high': 7, 'medium': 4, 'low': 2, 'info': 1}

        total_score = sum(severity_counts[severity] * weight
                          for severity, weight in weights.items())
        max_possible = sum(severity_counts.values()) * weights['critical']

        return (total_score / max_possible * 100) if max_possible > 0 else 0

    def _get_risk_level(self, risk_score: float) -> str:
        """Determine risk level based on score"""
        if risk_score >= 80:
            return "CRITICAL"
        elif risk_score >= 60:
            return "HIGH"
        elif risk_score >= 40:
            return "MEDIUM"
        elif risk_score >= 20:
            return "LOW"
        else:
            return "MINIMAL"


def main():
    """Main CLI entry point"""
    parser = argparse.ArgumentParser(
        description="Educational Penetration Testing Tool",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Basic penetration test
  python pentest_cli.py http://localhost:5000
  
  # Deep test with exploitation
  python pentest_cli.py http://localhost:5000 --deep --exploit
  
  # Specific test types
  python pentest_cli.py http://localhost:5000 --test-types recon vuln_scan
  
  # Test all demo applications
  python pentest_cli.py --demo-apps --educational
  
  # Generate detailed JSON report
  python pentest_cli.py http://localhost:5000 --output report.json --verbose

Security Notice:
This tool is for educational purposes and authorised testing only.
Only test applications you own or have explicit permission to test.
Unauthorized penetration testing is illegal.
        """
    )

    parser.add_argument('target', nargs='?',
                        help='Target URL or IP address to test')

    parser.add_argument('--demo-apps', action='store_true',
                        help='Test all demo applications')

    parser.add_argument('--test-types', nargs='+',
                        choices=['recon', 'vuln_scan',
                                 'web_app', 'exploit', 'all'],
                        help='Specific test types to run (default: auto-detect)')

    parser.add_argument('--deep', action='store_true',
                        help='Enable deep/thorough testing')

    parser.add_argument('--exploit', action='store_true',
                        help='Attempt exploitation for proof-of-concept (use responsibly)')

    parser.add_argument('--output', '-o', help='Output file path for report')

    parser.add_argument('--format',
                        choices=['json', 'txt', 'md', 'pdf'],
                        default='json',
                        help='Output format: json (JSON only), '
                             'md (JSON + Markdown), '
                             'pdf (JSON + Markdown + PDF), txt (text format)')

    parser.add_argument('--educational', action='store_true',
                        help='Enable educational mode with detailed explanations')

    parser.add_argument('--verbose', '-v', action='store_true',
                        help='Verbose output with detailed information')

    parser.add_argument('--quiet', '-q', action='store_true',
                        help='Quiet mode - minimal output')

    parser.add_argument('--force', action='store_true',
                        help='Skip confirmation prompts (use with caution)')

    args = parser.parse_args()

    # Configure logging based on verbosity
    if args.quiet:
        logger.setLevel(logging.ERROR)
    elif args.verbose:
        logger.setLevel(logging.DEBUG)

    # Display security notice
    if args.exploit and not args.force:
        print("‚ö†Ô∏è  SECURITY NOTICE:")
        print("This tool performs active security testing and exploitation.")
        print("Only use on applications you own or have explicit permission to test.")
        print("Unauthorized penetration testing is illegal and unethical.")
        print()

    # Initialize and run CLI
    cli = PentestCLI()
    cli.run_penetration_test(args)


if __name__ == "__main__":
    main()
